---
layout: post
image: /assets/img/js/javascript.png
# accent_image:
#   background: url('/assets/img/javascript.png') center/cover
#   overlay: false
accent_color: '#ccc'
theme_color: '#ccc'
description: >
  안녕하세요?!
invert_sidebar: false
categories:
  - frontend
  - js
---

# JS - Immutability

안녕하세요. 성장하는 것을 즐기는 `changuk`이라고 합니다. 현재 `fastcampus`에서 `frontend` 개발을 공부하고 있습니다. 강의를 들으면서 해온 것들을 작성하여 지식을 공유하고 또 제가 잊었을 때 다시 와서 볼 수 있도록 내용들을 정리하려고 합니다.

---

데이터 불변성(Immutability)에 대해 알아보도록 하겠습니다.

1. table of contents
{:toc .large-only}

---

## 데이터 불변성(Immutability)

JavaScript 데이터형은 크게 두가지로 나눌 수 있습니다.

| 데이터 Type | 원시 데이터 | 참조형 데이터 |
| ----------- | :---------: | :-----------: |
| String      |      O      |               |
| Number      |      O      |               |
| Boolean     |      O      |               |
| undefined   |      O      |               |
| null        |      O      |               |
| Object      |             |       O       |
| Array       |             |       O       |
| Function    |             |       O       |

**원시 데이터**는 JavaScript에서 사용할 수 있는 **기본데이터**를 의미하고 **참조형 데이터**는 ?

코드를 보며 이해해보겠습니다.

```javascript
let a = 1;
let b = 4;
console.log(a, b, a === b);
b = a;
console.log(a, b, a === b);
a = 7;
console.log(a, b, a === b);
let c = 1;
console.log(b, c, b === c);

// 출력 결과 :
// 1 4 false
// 1 1 true
// 7 1 false
// 1 1 true
```

먼저 a와 b가 각각 변수 1, 4로 할당되었습니다.
그 후에, a와 b가 일치하는지 비교하고 있습니다.

| 1번 메모리 | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :--------: | :--------: | :--------: | :--------: |
|    1(a)    |    4(b)    |            |            |

결과는 당연히 **false**가 나오네요. a, b값이 서로 다르니까요. 하지만 정확하게는 **각각의 변수가 가리키는 주소가 서로 다르기 때문에 일치하지 않는다고 판단**하는 것입니다.

이제 변수 b에 a를 할당해줍니다. 이는 a가 가리키고 있던 변수의 주소를 b에게 할당해 준다는 의미가 됩니다. 일치연산자로 비교해보면 **true**값을 출력해줍니다.

| 1번 메모리 | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :--------: | :--------: | :--------: | :--------: |
|  1(a, b)   |     4      |            |            |

변수 a에 새로운 값 7을 할당해주었습니다. 새로운 값이기 때문에 새 메모리에 7이 저장이 되겠군요. 이젠 a,b가 바라보는 메모리의 위치가 서로 다르기 때문에 일치연산자로 비교해보면 **false**값을 출력해줍니다.

| 1번 메모리 | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :--------: | :--------: | :--------: | :--------: |
|    1(b)    |     4      |    7(a)    |            |

이번에는 새로운 변수 c를 선언하고 1을 할당해주도록 하겠습니다. 과연 b와 비교하면 어떤 결과가 나타날까요? 일치연산자로 비교해보면 **true**값을 출력해줍니다. 변수 c에 할당해준 1은 4번째 메모리에 들어가는 것이 아닌, 이미 메모리에 있는 1을 가리키게 됩니다. 이를 JavaScript 데이터의 **불변성**이라고 이야기 합니다.

| 1번 메모리 | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :--------: | :--------: | :--------: | :--------: |
|  1(b, c)   |     4      |    7(a)    |            |

왜 불변성을 배워야 하는 것일까요?? 이유는 참조형 데이터를 온전히 이해하기 위해서 입니다. 원시데이터들은 기본적으로 불변성을 가지고 있기 때문에 쉽게 사용할 수 있지만 **참조형 데이터는 그렇지 않습니다**. 참조형 데이터들은 어떻게 메모리를 참조해서 사용하는지에 대한 개념을 알아봅시다.
먼저 코드를 보죠. 객체 데이터를 통해 참조형 데이터를 이해해 보겠습니다.

```javascript
let a = { k: 1 };
let b = { k: 1 };
console.log(a, b, a === b);
a.k = 7;
b = a;
console.log(a, b, a === b);
a.k = 2;
console.log(a, b, a === b);
let c = b;
console.log(a, b, c, a === c);
a.k = 9;
console.log(a, b, c, a === c);

// 출력 결과 :
// {k: 1} {k: 1} false
// {k: 7} {k: 7} true
// {k: 2} {k: 2} true
// {k: 2} {k: 2} {k: 2} true
// {k: 9} {k: 9} {k: 9} true
```

변수 a, b를 동일한 값을 갖는 객체 데이터로 선언했습니다. 그렇지만 비교연산자로 비교해보니 같지 않다고 나오네요. 결국 각각의 변수가 다른 메모리를 가리키고 있다는 내용을 알 수 있습니다. 이와 같이 **참조형 데이터는 원시데이터와는 달리 새로운 값을 만들 때 마다 새로운 메모리 주소에 할당되는 구조**를 갖고 있습니다. 따라서 참조형 데이터는 불변성이 없습니다. 일치연산자로 비교해본 결과 **false**가 출력됩니다.

| 1번 메모리 | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :--------: | :--------: | :--------: | :--------: |
| a = {k:1}  | b = {k:1}  |     {}     |     {}     |

이제 a 객체의 k 속성의 값을 7로 할당하고, b 객체가 a객체의 주소를 할당해줍니다. 일치연산자로 비교해본 결과, **true**가 출력되네요.

|  1번 메모리  | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :----------: | :--------: | :--------: | :--------: |
| a, b = {k:7} |     {}     |     {}     |     {}     |

여기서 참조형 데이터를 주의해서 사용해야하는 이유가 나옵니다. 객체 a의 k 속성 값을 2로 할당해주었고 다시 일치연산자로 a,b를 비교한 결과 **true**가 출력되는 것을 알 수 있습니다. 앞서 말씀드린대로, b 객체는 a 객체의 주소를 보고 있어서 a 객체가 바뀐다면 b 객체도 동일하게 바뀌게 됩니다. a만 바꾸길 원했지만 결과적으로 b도 바뀌게 되었군요.

|  1번 메모리  | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :----------: | :--------: | :--------: | :--------: |
| a, b = {k:2} |     {}     |     {}     |     {}     |

이제 c 변수에 b를 할당하고 있습니다. 일치연산자로 a 와 c를 비교해보니 **true**가 출력되었습니다. b 객체가 1번 메모리주소를 가지고 있기 때문에 c도 동일하게 1번 메모리주소를 갖게 되고, 이는 a 객체와 같은 값을 갖게 만듭니다.

|   1번 메모리    | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :-------------: | :--------: | :--------: | :--------: |
| a, b, c = {k:2} |     {}     |     {}     |     {}     |

객체 a의 k 속성값을 9로 바꾸고 일치연산자로 a, c를 비교했습니다. 결과는 이미 다 아시다시피 **false**가 나왔습니다.

|   1번 메모리    | 2번 메모리 | 3번 메모리 | 4번 메모리 |
| :-------------: | :--------: | :--------: | :--------: |
| a, b, c = {k:9} |     {}     |     {}     |     {}     |

따라서 할당연산자를 통해 참조형 데이터를 사용하는 게 아닌, 값을 복사하는 개념으로 사용해야 합니다. 이는 **얕은 복사**, **깊은 복사**로 나뉘어지게 되는데 다음 포스트에서 다루겠습니다.
